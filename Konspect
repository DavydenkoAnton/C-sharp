0История развития технологии программирования

1 Структурное программирование
2 Процедурное программирование(составные инструкции,ветвления и циклы процедуры) Си
3 Модульное программирование(к основной программе могут подключаться модули расположенные в отдельных файлах)
4 ООП (С++)
5 С#, JAVA

Причины возникновения платформы .NET:
1 необходимость межплатформенной преносимости ПО
2 проблема межязыкового взаимодействия
// платформа дотнет - это концепция развития, решающая две вышерасмотренные причины
3 упрощенное развертывание приложения и контроль версий
4 система 

технология дотнет отождествляется с Framework, которая представляет собой совокупность программных модулей,
с помощью которых в виновс выполняются приложения 

//достоинства и недостатки платформы  .NET
    достоинства:
1 малый объем программного кода(так как базовая библиотека классов есть на всех компах и может быть подключена)
2 наличие интегрированной среды времени выполнения(отвечает за безопасное выполнение кода) --==CLR==--(Common Language Runtime)
    недостатки:
1 задержка при первом запуске приложения
2 медленное исполнеие
3 межплатформенная непереносимость




Архитектура платформы .NET:

Схема компиляции на языке С++(исходный код -> препроцессор -> компиляется -> линковщик -> .ехе)
Схема компиляции С# (исходник .cs ->промежуточный MSIL или IL-> CLR->JIT-> .exe)

CLR - отвечает за компиляцию из промежуточного в испоняемый. отвечает за выполнение кода,
за управлением памяти, за работу с потоками и т.д.

CLS (Specific)-общеязыковой набор соглашений между разработчиками различных языков программирования,
	где определены общая система типов(CTS) и набор правил.
CTS (CommonTypeSystem)- орпеделяет правила в отношение ипользуемых типов данных

FCL (FrameworkClassLibrary)- базовая библиотека классов, содержащая пространство имен решающих
	конкретные задачи. Позволят генерировать компактный код.

Пространство имен:
System                 для математических расчетов
System.Collection      
System.IO              
System.Drawing
System.Data


Языки платформы .NET:
Visual C++
C#
J#
F#
VB.Net
Fortran.Net

Рефлекторы и дотфускаторы:
Рефлексия или отражение типов данных- это процесс получения информации о типе данных и его компонентах
	во время выполнения программ.
Рефлектор - это программное средство выполняющее программное средствоили рефлексию

Возможности рефлектора
1 возможность увидеть как выглядет ехе файл после его комиляции
2 можно просматривать промежуточный код 
3 использовать для анализа при тестировании программы 


дотфускатор- это программа содержащие методы для запутывания промежуточного кода, чтобы нельзя было получить исходный


//////////24.02.2015

Сборка-это наименьшее единица из совокупности которых, построена платформа .Net
Сборки обеспечивают возможность ипользования повторного кода, определяют границы типов, подддерживают версии,
являются самоописываемыми и поддаются конфигурированию.
Сборки бывают двух видов. однофайловые и многофайловые:

Однофайловые:
1 манифест
2 метаданные
3 MSIL код
4 ресурсы

Многофайловые:
1 манифест (обязательно)
2 метаданные
3 MSIL код

Манифест-обязательная часть сборки, которая ее описывает.
В манифесте хранятся следующие данные:
1 список файлов входящие в сборку
2 список сборок

Метаданные описывают типы входящие в сборку

--------------------------------------------------------
------------ Типы данных -------------------------------
--------------------------------------------------------

Язык Си шарп - это язык со строгой типизацией, тоесть любая переменная должна иметь тип

куча-динамическая память

Значимые (стек):
-простые типы данных
-структура 
-перечисляемые(enum)

Ссылочные(куча):
-классы
-интерфейсы
-массивы
-строки
-делегаты

встроенные типы данных:
-целочисленные
	byte,Sbyte   - 1 (байт)
	char         - 2
	short,Ushort - 2
	int, Uint    - 4
	long,ulong   - 8
-дробные
	float        (7 знаков)
	double       (15-16 знаков)
	decimal      (28-29 знаков)
-логические
	bool 	     - 1 (байт)


---------  Литералы  ------------
Литералы в си шарп - это фиксированое значение, котрое представлено в понятной форме или по-другому константное значение
Все литералы должны иметь тип. Для отнесения литерала к определенному типу, должно быть несколько правил
1 для целочисленного литерала назначается наиеньший тип. позволяющий его хранить
2 все дробные значения имеют тип дабл
для явной спецификации предусмотрены явные сиволы 
L long
F float
D double
M decimal
U unsinged
пример 100U  12.5F

Строковые литералы выражаются в двойных кавычках " " Для того чтобы управляющие символы не работали, перед строковой 
константой ставится собака  пример ( @"C:\users"  ) 

----- Переменные -----

!!! СиШарп- регистрозависимый !!!
область видимость такая же как и в Си

----- Ввод вывод -----

дано число: вывести на экран число на экран


преоброзование типов
явные и неявные
int x; double y;
неявное-выполняется автоматически при приведении к более точному типу или большему 

явное осуществляется когда больший тип преобразуется к меньшему. так как возможна потеря даных
Для явнонго приведения типа, необходимо уазать этот тип данных  в скобках непосредственно перед переменной
 x=(int)y;

Также для приведения типлв можно использовать класс конверт

----Операторы----


--- Неявнотипизированные переменные ----
 создаются с  с помощью var  и должна быть проинициолизирована( var x=7;  var y=8,5; var z=3,4F )
 нельзя неявно преобразовывать логический тип в целый
 также нет автоматического преобразования из символьного в целый

---- генерация случайных чисел ----
класс РАНДОМ, который для вычисления начального числа последовательности случайных чисел использует системное время

Random r=new.Random();
r.Next();       -границы от 0   ... int32
r.Next(7);      -границы от 0   ... 6
r.Next(2,5);    -границы от 2   ... 4
r.NextDouble(); -границы от 0.0 ... 1


-- одномерные массивы --

char[] array=new char[100];
Массивы в си шарп является ссылочным типом данных, тоесть размещается в динамической памяти
Размерность может задаваться переменной
int n=int.Parse(Console.Read());
int[] arr=new int[n];

Инициализация массивов:
После выделения памяти все элементы массива обнуляются автоматически
способы инициализации:

1 int[] arr=new int[4]{1,2,3,4};
  int[] arr=new int[ ]{1,2,3,4};
  int[] arr={1,2,3,4};

2 int[] arr=new int[n];
  через цикл, например for(); arr[i]=i;


------- многомерные массивы ----------

char[,] arr=new char[n,m];

Инициализация многомерных массивов:
char[,] arr=new char[2,3]{{1,2,3}{4,5,6}};
char[,] arr={{1,2,3}{4,5,6}};

-- рваный массив --

int[][] arr=new int [3][];
arr[0]={1,2,3};
arr[0]={1};
arr[0]={1,2,3,4,5};

если двумерный массив можно представить в виде таблицы,то рваный массив можно определить как массив,
строки которого могут иметь различную длину.
Доступ к элементу рваного массива осуществляется через индекс в разных квадратных скобках
Выход за пределы массива или обращение к несуществуещему элементу приведет к ошибке


------ Особенности работы с массивами ------
Массив является объектом класса Array
arr.Lenght - возвращает количество элементов, которое хранит массив. В двумерном вернет все элементы каждой строки. 
У рваного возвращает количество строк, а при обращении к строке возвращает количество элементов.

------ Присвоение массивов друг другу ------
При копировании массива к массиву, они будут указывать на один участок памяти.
arr.Clone();   - копирует значеня
arr.Copy();    - копирует адреса  // Array.Copy(текущий массив, принимающий массив, размерность)
arr.Reverse(); - 
Array.Clear(массив,с какого элемента, arr.GetLenght(0)<-новый размер массива);


------ Строки -----
Строки в си шарпе предсавлены классом String.Следовательно как и массивы являются ссылочными или объектами.
1 Создание строк
string str1="Простая строка";
char[] chrArr{'П','р','о','с','т','а','я',' ','с','т','р','о','к','а'};
string str2=new string (chArr);
string str3=new string (chArr,8,6);
string str4=new string ('$',10);

----- Работа со строками ------
Длина строки определяется свойством Lenght();
Lenght() - возвращает длину строки.
Строки в си шарп неизменны.
Для конкатенации строк используется символ +
Switch(str)
строки могут быть объединены в массив //string[] arr=new string[x];
для сравнения строк используют ==  и  !=,  другие операторы сравнения сравнивают адреса строк

----------- Основные методы по работе сос строками ---------


----------------------26.02.2015----------------------------

строки типа стринг билдер яввляются изменяемыми, но имеют меньше возможностей по работе со строками
Строки типа стринг при создании выделяют столько памяти . сколько необходимо для хранения строки
Строки типа стринг билдер выделяют изначально память в 16 символов.а если строка занимает больше места. она удваивается
Синтаксис:
StringBuilder str = new StringBuilder("Привет, всем!");
Lenght   - длина. Показывает длину строки находящуюся в объекте в данный момент
Capacity - емкость. Максимальная длинна строки. которая может поместиться в выделенную для объекта память

По умолчанию для пустой строки StringBuilder емкость 16 символов

Методы:
Append        - добавляет строку к текущей строке
AppendFormat  - добавляет форматированную строку к текущей строке
Insert        - вставляет подстроку в строку 
Remove        - удаляет символ в строке
Replace       - заменяет строку
ToString      - конвертирует в string


---------------------------------------------------------------------------------------------------------
--------------------------------------------- Классы ----------------------------------------------------
---------------------------------------------------------------------------------------------------------
[<атрибуты>] [<спецификатор>] class <имя класса>
{
//тело класса
}
class User{
public string Name;
public int Age;
void ShowParametr(string N,int A);
}

User man=new User();
User man=new User{Name="Jimmy",Age=20};
User man=new User(Name="Jimmy",Age=20);
При копировани переменных происходит перенос значений, а при копированни объектов они будут указывать на одну область памяти!
public private protected internal
если метод ничего не возвращает то тип воид и ретурн не пишется
фактические парааметры метода являются локальными по отношению к этому методу и уничтожаются после выхода из метода

------------------------------Передача аргументов в вметод по ссылке и по значению------
  При классической передаче агументов в метод, используется передача по значению, тоесть переданные аргументы копируются
и становятся локальными по отношению к методу
  Есл из метода надо вернуть более одного значения. то в такой метод необходимо передавть значений по ссылке. Для передачи
по ссылке используются два модификатора ref и  out.
  ref и  out должны указываться как при передаче аргументов, так и в списке параметра метода 
  Переменные передаваемые с модификаторами реф, должны быть проинициолизированы при передаче
  Переменная аут может не иметь инициализации, но внутри метода должны ОБЯЗАТЕЛЬНО проиницилизированы
  В методе параметр аут считается не проиниционизирован
  Если метод принимает несколько параметров одним из которых является парамс. то парамс должен идти последним
  Всписке параметров метода может быть только один парамс

----------------Модификатор params----------------------------
  Ключевое слово парамс позволяет передавать методу переменное количество одного типа в ввиде единственного логического параметра
  В кечестве аргумента в метод с модификатором парамс может быть передан как отдельный массив так и множество однотипных элементов через запятую
 

/////////---02.03.2015------------------------------------////////////////////////////////////////////////
-----------Необязательные и именованные аргументы---------------------
  Необязательные аргументы необходимы для того, чтобы использовать по умолчанию для некотрых параметров метода, указываются в конце списка параметоров
через знак ровно и присвоенеие значения по умолчанию.
  Именованные аргументы предназанчены для пердачи в метод в любой последовательности.При пеередаче необходимо указать имя параметра, двоеточие и его значение

  Конструктор это метод класса, предназначенный для инициализации объекта класса, ничего не возвращает. может принимать неогр. число параметоров. чаще используется
с паблик. Каждый класс с конструктором по умолчанию

  !!!!!!!!!! При создании конструктора с параметрами, конструктор без параметорв(по умолчанию) затирается, поэтому при создании пользовательских конструкторов, 
необходимо сразу создать изначально конструктор по умолчанию (если он нужен).
  
  Деструктор это метод, который вызывается автоматическим сборщиком мусора пееред удалением объекта из памяти.ничего не возвращает, перед ним тильда ('~')

 ---This--- обеспечивает доступ к текущему объекту.
  Использование :

  1 для решения неодназачности контекста

			void f(int ch){
				return this.ch=ch;
			}

  2 сцепление конструкторов используется когда имеется класс орпеделяющий несколько конструкторов, в каждом из констукторов необходимо делать однотипные 
проверки на инициализацию полей. Для предотвращеиня избыточной проверки один конструктор может вызывать другой.
	Очередность вызова конструктора в цепочке: 1 вызов, 2 выполнение

--------------- Статические элементы класса ------------------

	1 статические используются на уровне класса от , объявляются с помощью ключевого слова static
	статические поля (типо глобальные поля). Все объекты класса используют статическую переменную. для доступа к статической переменной
используем имя класса точка имя переменной Class.x;
	2 статические методы используются на уровне класса и вызываютя через имя класса. Могут обращаться только к статическим переменным и методам данного класса.
Нельзя использовать ссылку *this.
	3 статические конструкторы испоьзуются для инициализации компонентов применяемых ко всему классу, тоесть для статических.Вызывается автоматически
при первом обращении к имени класса
	4 Статические классы должны содержать только стстатические члены, объект статического класса создать нельзя. Используются для хранения совокупности связанных
друг с другом статическим методом.

--------------- Частичные типы ----------------------

	Если необходимо разбить класс на несколько файлов в рамках одного пространства имен. то перед словом CLass ставиться слово partial

--------------- Исключительные ситуации -------------
	Исключительные классы exception каждый класс описывает конкретную исключительную ситуацию. Для конструкции используют try catch finnally

try{
//код который хотим отследить
}
catch(тип исключения имя){
// что сделать
}
finnaly{
// код запускается в любом случае, и является не обязательным
//чаще используетсся для освобождения ресурсов
}
 Порядок
1 вход в блок try
2 если в try исключений не возникло, то к finally.
3 если втрай есть искл то переход к соответствующему кэтч.Если в кэтч нет выхода из метода. то далее переход к инструкции после всех болков catch или finally
4 при наличии блока finally происходит его выполнение

Исключения могут быть сгенерированы внутри метода, который был вызван из блока try
Если после блока TRY используется несколько CATCH то каждый блок должен иметь орпеделенный тип исключения
Блок catch без параметров является универсальным и срабатывает для всех типов ошибок. его необходимо размещать последним. 
вложенные блоки трай можно вложить друг в друга, исключения во внутреннем блоке и неперехваченная внутренним кэтч блоком. передается во внешний трай блок, чаще
всего используется для обработки различных категорий ошибок. во внутренней менее опасные.
	
///---------04.03.2015--------------

					-------Перегрузка оператора---------

	Требования к перегрузке  операторов
 1 перегрузка оператоов позволяет указать как стандартные операторы будут использоваться с объектами класса
 2 перегрузка должна выполняться открытыми статическими методами класса
 3 параметры перегружаемого метода не должны включать параметры out и ref
 4 у перегружаемого метода тип возвращаемого значения или тип одного из параметров должен совпадать с типом
   в котором выполняется перегрузка
 5 невозможно изменить значения стандартных операций и стандартных типов данных

	Ограничения на перегрузку:
 1 перегрузка не может изменять приоритет операторов 
 2 перегрузка не может изменять количество операндов с которым работает оператор

	Опреаторы которые не допускают перегрузку:

= += -= *= /= >>= . ?: new as is typeof -> sizeof *-(разыменование) &

(условие)?(выражение1):(выражение2) унарный оператор сравнения

public static тип возвр. данных operator символ оператора ( список параметров)

	Перегрузка унарных операторов

public static тип возвр. данных operator символ оператора ( тип операнд )

Перегрузка постфиксной и префиксной форме операторов отдельно не выделяется
Опреатор - не должен изменять состояние текущего объекта, а возвращать новый объект с измененным знаком.

	Перегрузка бинарных операторов

public static тип возвр. данных operator символ оператора ( тип операнд_1, тип операнд_2)

при применении бинарных операций и встроенного типа данных важен порядок следования операндов
а+10 и 10+а должны иметь два перегруженых метода.

	Операторы отношений

Операторы отношений перегружаются парно
|>,<|  |>=,<=| |==,!=|
Как правило перегруженный оператор отношения возвращает логический тип true или false

	Перегрузка true false
Операторы true false менять в паре

	Перегрузка логического
Перегруженнные логические операторы должны возвращать тип bool
   ---  &   ---   |   ---   !   --- побитовые
   ---  &&  ---   ||  ---   
	
a | b | a&b | a|b | !a
--|---|-----|-----|----
1 | 0 |  0  |  1  | 0
0 | 1 |  0  |  1  | 1 
0 | 0 |  0  |  0  | 1
1 | 1 |  1  |  1  | 0

	Для перегрузки операторов по сокращенной схеме. 
1 перегрузить побитовые операторы
2 должны возвращать объект класса, для которого преегружаются эти операторы
3 каждый параметр должен быть ссылкой на объект класса
4 также необходимо перегрузить операторы тру и фолс
 	
	Перегрузка операторов преоброзования
public static explicit operator тип_рез (исходный.тип v){ return значение;}  // явное
public static implicit operator тип_рез (исходный.тип v){ return значение;}  // неявное

В одном классе нельзя делать одновременную перегрузку двух, только одного




                      ------ Cвойства и индексаторы -------



public тип_возвр_данных ИМЯ{
		set{имя_поля=value;}
		get{return имя_поля}
}

свойства предназначены для организации доступа к закрытым полям класса
свойства заменяют открытые методы, могут иметь аксессоры set и get, в каждом из которых осуществляются проверки присвоения
и возвращения результата переменной. для котрой  было создано свойство

Особенности работы со свойствами
1 свойство может содержать один либо два аксессора (отсутствие вааще невозможно!!!!!!) 
2 свойство не может быть перегружено
  свойство не может быть передано в метод параметром ref или out
3 свойство не должно изменять значение переменной в аксессоре get
4 свойство может быть статическим
Один из аксессоров в свойтсве может иметь различные варианты спецификаторов доступа
Второй аксессор должен иметь спецификатор доступа соответствующий спецификатору способа доступа

	                     Автоматические свойства 
Для полей класса можно создавать автоматические свойства, тоесть записывать аксессоры get set без тела

public int Size{get; set;}

public int Width {get; private set;}

Должны присутствовать оба значения

  

                  ---------- Индексаторы --------------


Индексатор это разновидность свойства (свойство с параметром), которая применяется для обращения к объектам класса так, словно они являются элементами
коллекции или массива.
Индексатор ппредставляет собой перегрузку оператора квадратные скобки - []
Cbynfrcbc:
спецификатор_доступа тип_эл. this [тип индекс]{
	get{ ... }
	set{ ... }
}

public int this[int i, string y]{
	get{return arr[i]}
	set{if(value>100 || value<0)
	    temp[i]=0;
	else
	    temp[i]=value;
}

Особенности индексаторов:
1 Индексатор имеет имя this и должен приниамать хотя бы один параметр (можно больше)
2 Индексатор может принимать любой тип параметра.
3 В одном классе можно создавать несколько индексаторов, но они должны иметь разные списки принимаемых значений (перегрузка индексаторов)
4 Индексаторы могут иметь могут иметь один или два аксессора (get, set)
5 Индексаторы нельзя передавать в методы в качестве параметров
6 Индексатор должен быть членом экземпляром своего класса, поэтому его нельзя объявлять static

Индексатор может не использовать массив класса достаточно чтобы индексатор обеспечивал функционирование, которое для пользователя бы выглядело как работа с массивом




                ----------- Наследование -----------




Синтаксис:

class Monster {
...
}

class Daemon: Monster{
...
}

Множественное наследвание низзя!!!
Класс может иметь неограниченное кол-во потомков.

private   - только для базового
public    - для всех классов
protected - для наследуемых

Особенности использования конструкторов при наследовании
Конструктор базового класса создает часть объекта соответсвующий базовому классу,
а конструктор проиводдного класса часть. соответсвующую производному классу.
Поэтому при созданиии объекта произв. класса будут выполнены конструкторы произв. и базового классов
Порядок вызова конструктора

1 вызывается конструктор производодного класса
2 вызывается конструктор базового класса
  а) либо по умолчанию,если не т явного
  б) вызов конструктора с параметром, который соответсвует параметрам следующим после ключевого слова base. 
Синтаксис для б:
Конструктор произв констр(параметры()):base(параметры){
...
}


3 Выполнение конструктора базового класса
4 Возврат к телу производного класса и его выполнение

--------- Если в иерархии наследования стоит больше двух классов. то вызов конструкторов осуществляется от производного через базовые
к самому общему базовому классу. а выполнение наоборот 
---------Использование производного слова base
1. это вызов конструктора базового класса (с помощью base вызывается тот конструктор, параметры которого соответствуют переданным аргументам в base
   base всегда отсылает к базовому классу, стоящему непосредственно над вызывающим классом. Если base отсутствует, то автом. вызывается конструктор базового класса по умолчанию
2. для доступа к члену базового класса, который скрыт за членом производного класса
Производный  класс может определить член, имя которого совпадает с именем члена базового класса, В этом случае член базового класса становиться скрытым в производном классе. Данная ситуация не вызовет ошибки. А только предупреждение.  Для предотвращения которого необходимо указать слово new перед членом производного класса. Скрывать можно методы свойства переменные. Для доступа к скрытым элементам из базового класса к производным можно со словом ‘ base. ’
-------Использование ссылок базового класса на производный.
Объект одного класса не может быть присвоен объекту другого класса за исключением того, если они находятся в иерархии наследования
!!!!!!! Ссылки базового класса можно присвоить объект любого производного класса
Class X{
Int a;
}
Class Y:X{
Int b;
}
X x1=new Y();
x1.a=4;
x1.b=4; //Error

Тип ссылочной переменной, а не тип объекта на который она ссылается, определяет, какие члены могут быть доступны.
Чаще всего ссылки типа базовый класс на производный. Используются при создании универсальных методов, которые принимают ссылки базового класса, а передавать в них моно объекты производного класса.
Виртуальным называется метод virtual переопределяется в одном или нескольких производных классах с помоью override
Виртуальные методы имеют смысл, когда они вызываются через ссылку на базовый класс.
!!! Тип объекта, на который указывает ссылка, а не тип ссылки определят какая версия виртуального метода будет выполнена
Ghb gthtjghtltktybb dbhnefkmyjuj vtnjlf сигнатуры виртуального и метода переопределенного должны совпадать
Виртуальный метод нельзя переопределять как статический. Переопределение виртуальных методов является основой диспетчеризацией методов
Диспетчиризация это механизм вызова преопределенного метода во время выполнения программы а не во время компиляции. Виртуальный метод в производном классе не обяз, если 
Помимо методов виртуальными могут быть и свойства
Если производный класс не переопределяет класс в случае многоуровневой иерархии, то будет выполнен первый переопределенный метод, который обнаружится при просмотре иерархической лестницы снизу вверх.
