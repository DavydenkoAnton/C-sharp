0История развития технологии программирования

1 Структурное программирование
2 Процедурное программирование(составные инструкции,ветвления и циклы процедуры) Си
3 Модульное программирование(к основной программе могут подключаться модули расположенные в отдельных файлах)
4 ООП (С++)
5 С#, JAVA

Причины возникновения платформы .NET:
1 необходимость межплатформенной преносимости ПО
2 проблема межязыкового взаимодействия
// платформа дотнет - это концепция развития, решающая две вышерасмотренные причины
3 упрощенное развертывание приложения и контроль версий
4 система 

технология дотнет отождествляется с Framework, которая представляет собой совокупность программных модулей,
с помощью которых в виновс выполняются приложения 

//достоинства и недостатки платформы  .NET
    достоинства:
1 малый объем программного кода(так как базовая библиотека классов есть на всех компах и может быть подключена)
2 наличие интегрированной среды времени выполнения(отвечает за безопасное выполнение кода) --==CLR==--(Common Language Runtime)
    недостатки:
1 задержка при первом запуске приложения
2 медленное исполнеие
3 межплатформенная непереносимость




Архитектура платформы .NET:

Схема компиляции на языке С++(исходный код -> препроцессор -> компиляется -> линковщик -> .ехе)
Схема компиляции С# (исходник .cs ->промежуточный MSIL или IL-> CLR->JIT-> .exe)

CLR - отвечает за компиляцию из промежуточного в испоняемый. отвечает за выполнение кода,
за управлением памяти, за работу с потоками и т.д.

CLS (Specific)-общеязыковой набор соглашений между разработчиками различных языков программирования,
	где определены общая система типов(CTS) и набор правил.
CTS (CommonTypeSystem)- орпеделяет правила в отношение ипользуемых типов данных

FCL (FrameworkClassLibrary)- базовая библиотека классов, содержащая пространство имен решающих
	конкретные задачи. Позволят генерировать компактный код.

Пространство имен:
System                 для математических расчетов
System.Collection      
System.IO              
System.Drawing
System.Data


Языки платформы .NET:
Visual C++
C#
J#
F#
VB.Net
Fortran.Net

Рефлекторы и дотфускаторы:
Рефлексия или отражение типов данных- это процесс получения информации о типе данных и его компонентах
	во время выполнения программ.
Рефлектор - это программное средство выполняющее программное средствоили рефлексию

Возможности рефлектора
1 возможность увидеть как выглядет ехе файл после его комиляции
2 можно просматривать промежуточный код 
3 использовать для анализа при тестировании программы 


дотфускатор- это программа содержащие методы для запутывания промежуточного кода, чтобы нельзя было получить исходный


//////////24.02.2015

Сборка-это наименьшее единица из совокупности которых, построена платформа .Net
Сборки обеспечивают возможность ипользования повторного кода, определяют границы типов, подддерживают версии,
являются самоописываемыми и поддаются конфигурированию.
Сборки бывают двух видов. однофайловые и многофайловые:

Однофайловые:
1 манифест
2 метаданные
3 MSIL код
4 ресурсы

Многофайловые:
1 манифест (обязательно)
2 метаданные
3 MSIL код

Манифест-обязательная часть сборки, которая ее описывает.
В манифесте хранятся следующие данные:
1 список файлов входящие в сборку
2 список сборок

Метаданные описывают типы входящие в сборку

--------------------------------------------------------
------------ Типы данных -------------------------------
--------------------------------------------------------

Язык Си шарп - это язык со строгой типизацией, тоесть любая переменная должна иметь тип

куча-динамическая память

Значимые (стек):
-простые типы данных
-структура 
-перечисляемые(enum)

Ссылочные(куча):
-классы
-интерфейсы
-массивы
-строки
-делегаты

встроенные типы данных:
-целочисленные
	byte,Sbyte   - 1 (байт)
	char         - 2
	short,Ushort - 2
	int, Uint    - 4
	long,ulong   - 8
-дробные
	float        (7 знаков)
	double       (15-16 знаков)
	decimal      (28-29 знаков)
-логические
	bool 	     - 1 (байт)


---------  Литералы  ------------
Литералы в си шарп - это фиксированое значение, котрое представлено в понятной форме или по-другому константное значение
Все литералы должны иметь тип. Для отнесения литерала к определенному типу, должно быть несколько правил
1 для целочисленного литерала назначается наиеньший тип. позволяющий его хранить
2 все дробные значения имеют тип дабл
для явной спецификации предусмотрены явные сиволы 
L long
F float
D double
M decimal
U unsinged
пример 100U  12.5F

Строковые литералы выражаются в двойных кавычках " " Для того чтобы управляющие символы не работали, перед строковой 
константой ставится собака  пример ( @"C:\users"  ) 

----- Переменные -----

!!! СиШарп- регистрозависимый !!!
область видимость такая же как и в Си

----- Ввод вывод -----

дано число: вывести на экран число на экран


преоброзование типов
явные и неявные
int x; double y;
неявное-выполняется автоматически при приведении к более точному типу или большему 

явное осуществляется когда больший тип преобразуется к меньшему. так как возможна потеря даных
Для явнонго приведения типа, необходимо уазать этот тип данных  в скобках непосредственно перед переменной
 x=(int)y;

Также для приведения типлв можно использовать класс конверт

----Операторы----


--- Неявнотипизированные переменные ----
 создаются с  с помощью var  и должна быть проинициолизирована( var x=7;  var y=8,5; var z=3,4F )
 нельзя неявно преобразовывать логический тип в целый
 также нет автоматического преобразования из символьного в целый

---- генерация случайных чисел ----
класс РАНДОМ, который для вычисления начального числа последовательности случайных чисел использует системное время

Random r=new.Random();
r.Next();       -границы от 0   ... int32
r.Next(7);      -границы от 0   ... 6
r.Next(2,5);    -границы от 2   ... 4
r.NextDouble(); -границы от 0.0 ... 1


-- одномерные массивы --

char[] array=new char[100];
Массивы в си шарп является ссылочным типом данных, тоесть размещается в динамической памяти
Размерность может задаваться переменной
int n=int.Parse(Console.Read());
int[] arr=new int[n];

Инициализация массивов:
После выделения памяти все элементы массива обнуляются автоматически
способы инициализации:

1 int[] arr=new int[4]{1,2,3,4};
  int[] arr=new int[ ]{1,2,3,4};
  int[] arr={1,2,3,4};

2 int[] arr=new int[n];
  через цикл, например for(); arr[i]=i;


------- многомерные массивы ----------

char[,] arr=new char[n,m];

Инициализация многомерных массивов:
char[,] arr=new char[2,3]{{1,2,3}{4,5,6}};
char[,] arr={{1,2,3}{4,5,6}};

-- рваный массив --

int[][] arr=new int [3][];
arr[0]={1,2,3};
arr[0]={1};
arr[0]={1,2,3,4,5};

если двумерный массив можно представить в виде таблицы,то рваный массив можно определить как массив,
строки которого могут иметь различную длину.
Доступ к элементу рваного массива осуществляется через индекс в разных квадратных скобках
Выход за пределы массива или обращение к несуществуещему элементу приведет к ошибке


------ Особенности работы с массивами ------
Массив является объектом класса Array
arr.Lenght - возвращает количество элементов, которое хранит массив. В двумерном вернет все элементы каждой строки. 
У рваного возвращает количество строк, а при обращении к строке возвращает количество элементов.

------ Присвоение массивов друг другу ------
При копировании массива к массиву, они будут указывать на один участок памяти.
arr.Clone();   - копирует значеня
arr.Copy();    - копирует адреса  // Array.Copy(текущий массив, принимающий массив, размерность)
arr.Reverse(); - 
Array.Clear(массив,с какого элемента, arr.GetLenght(0)<-новый размер массива);


------ Строки -----
Строки в си шарпе предсавлены классом String.Следовательно как и массивы являются ссылочными или объектами.
1 Создание строк
string str1="Простая строка";
char[] chrArr{'П','р','о','с','т','а','я',' ','с','т','р','о','к','а'};
string str2=new string (chArr);
string str3=new string (chArr,8,6);
string str4=new string ('$',10);

----- Работа со строками ------
Длина строки определяется свойством Lenght();
Lenght() - возвращает длину строки.
Строки в си шарп неизменны.
Для конкатенации строк используется символ +
Switch(str)
строки могут быть объединены в массив //string[] arr=new string[x];
для сравнения строк используют ==  и  !=,  другие операторы сравнения сравнивают адреса строк

----------- Основные методы по работе сос строками ---------


----------------------26.02.2015----------------------------

строки типа стринг билдер яввляются изменяемыми, но имеют меньше возможностей по работе со строками
Строки типа стринг при создании выделяют столько памяти . сколько необходимо для хранения строки
Строки типа стринг билдер выделяют изначально память в 16 символов.а если строка занимает больше места. она удваивается
Синтаксис:
StringBuilder str = new StringBuilder("Привет, всем!");
Lenght   - длина. Показывает длину строки находящуюся в объекте в данный момент
Capacity - емкость. Максимальная длинна строки. которая может поместиться в выделенную для объекта память

По умолчанию для пустой строки StringBuilder емкость 16 символов

Методы:
Append        - добавляет строку к текущей строке
AppendFormat  - добавляет форматированную строку к текущей строке
Insert        - вставляет подстроку в строку 
Remove        - удаляет символ в строке
Replace       - заменяет строку
ToString      - конвертирует в string


---------------------------------------------------------------------------------------------------------
--------------------------------------------- Классы ----------------------------------------------------
---------------------------------------------------------------------------------------------------------
[<атрибуты>] [<спецификатор>] class <имя класса>
{
//тело класса
}
class User{
public string Name;
public int Age;
void ShowParametr(string N,int A);
}

User man=new User();
User man=new User{Name="Jimmy",Age=20};
User man=new User(Name="Jimmy",Age=20);
При копировани переменных происходит перенос значений, а при копированни объектов они будут указывать на одну область памяти!
public private protected internal
если метод ничего не возвращает то тип воид и ретурн не пишется
фактические парааметры метода являются локальными по отношению к этому методу и уничтожаются после выхода из метода

------------------------------Передача аргументов в вметод по ссылке и по значению------
  При классической передаче агументов в метод, используется передача по значению, тоесть переданные аргументы копируются
и становятся локальными по отношению к методу
  Есл из метода надо вернуть более одного значения. то в такой метод необходимо передавть значений по ссылке. Для передачи
по ссылке используются два модификатора ref и  out.
  ref и  out должны указываться как при передаче аргументов, так и в списке параметра метода 
  Переменные передаваемые с модификаторами реф, должны быть проинициолизированы при передаче
  Переменная аут может не иметь инициализации, но внутри метода должны ОБЯЗАТЕЛЬНО проиницилизированы
  В методе параметр аут считается не проиниционизирован
  Если метод принимает несколько параметров одним из которых является парамс. то парамс должен идти последним
  Всписке параметров метода может быть только один парамс

----------------Модификатор params----------------------------
  Ключевое слово парамс позволяет передавать методу переменное количество одного типа в ввиде единственного логического параметра
  В кечестве аргумента в метод с модификатором парамс может быть передан как отдельный массив так и множество однотипных элементов через запятую
 

/////////---02.03.2015------------------------------------////////////////////////////////////////////////
-----------Необязательные и именованные аргументы---------------------
  Необязательные аргументы необходимы для того, чтобы использовать по умолчанию для некотрых параметров метода, указываются в конце списка параметоров
через знак ровно и присвоенеие значения по умолчанию.
  Именованные аргументы предназанчены для пердачи в метод в любой последовательности.При пеередаче необходимо указать имя параметра, двоеточие и его значение

  Конструктор это метод класса, предназначенный для инициализации объекта класса, ничего не возвращает. может принимать неогр. число параметоров. чаще используется
с паблик. Каждый класс с конструктором по умолчанию

  !!!!!!!!!! При создании конструктора с параметрами, конструктор без параметорв(по умолчанию) затирается, поэтому при создании пользовательских конструкторов, 
необходимо сразу создать изначально конструктор по умолчанию (если он нужен).
  
  Деструктор это метод, который вызывается автоматическим сборщиком мусора пееред удалением объекта из памяти.ничего не возвращает, перед ним тильда ('~')

 ---This--- обеспечивает доступ к текущему объекту.
  Использование :

  1 для решения неодназачности контекста

			void f(int ch){
				return this.ch=ch;
			}

  2 сцепление конструкторов используется когда имеется класс орпеделяющий несколько конструкторов, в каждом из констукторов необходимо делать однотипные 
проверки на инициализацию полей. Для предотвращеиня избыточной проверки один конструктор может вызывать другой.
	Очередность вызова конструктора в цепочке: 1 вызов, 2 выполнение

--------------- Статические элементы класса ------------------

	1 статические используются на уровне класса от , объявляются с помощью ключевого слова static
	статические поля (типо глобальные поля). Все объекты класса используют статическую переменную. для доступа к статической переменной
используем имя класса точка имя переменной Class.x;
	2 статические методы используются на уровне класса и вызываютя через имя класса. Могут обращаться только к статическим переменным и методам данного класса.
Нельзя использовать ссылку *this.
	3 статические конструкторы испоьзуются для инициализации компонентов применяемых ко всему классу, тоесть для статических.Вызывается автоматически
при первом обращении к имени класса
	4 Статические классы должны содержать только стстатические члены, объект статического класса создать нельзя. Используются для хранения совокупности связанных
друг с другом статическим методом.

--------------- Частичные типы ----------------------

	Если необходимо разбить класс на несколько файлов в рамках одного пространства имен. то перед словом CLass ставиться слово partial

--------------- Исключительные ситуации -------------
	Исключительные классы exception каждый класс описывает конкретную исключительную ситуацию. Для конструкции используют try catch finnally

try{
//код который хотим отследить
}
catch(тип исключения имя){
// что сделать
}
finnaly{
// код запускается в любом случае, и является не обязательным
//чаще используетсся для освобождения ресурсов
}
 Порядок
1 вход в блок try
2 если в try исключений не возникло, то к finally.
3 если втрай есть искл то переход к соответствующему кэтч.Если в кэтч нет выхода из метода. то далее переход к инструкции после всех болков catch или finally
4 при наличии блока finally происходит его выполнение

Исключения могут быть сгенерированы внутри метода, который был вызван из блока try
Если после блока TRY используется несколько CATCH то каждый блок должен иметь орпеделенный тип исключения
Блок catch без параметров является универсальным и срабатывает для всех типов ошибок. его необходимо размещать последним. 
вложенные блоки трай можно вложить друг в друга, исключения во внутреннем блоке и неперехваченная внутренним кэтч блоком. передается во внешний трай блок, чаще
всего используется для обработки различных категорий ошибок. во внутренней менее опасные.
	
///---------04.03.2015--------------

					-------Перегрузка оператора---------

	Требования к перегрузке  операторов
 1 перегрузка оператоов позволяет указать как стандартные операторы будут использоваться с объектами класса
 2 перегрузка должна выполняться открытыми статическими методами класса
 3 параметры перегружаемого метода не должны включать параметры out и ref
 4 у перегружаемого метода тип возвращаемого значения или тип одного из параметров должен совпадать с типом
   в котором выполняется перегрузка
 5 невозможно изменить значения стандартных операций и стандартных типов данных

	Ограничения на перегрузку:
 1 перегрузка не может изменять приоритет операторов 
 2 перегрузка не может изменять количество операндов с которым работает оператор

	Опреаторы которые не допускают перегрузку:

= += -= *= /= >>= . ?: new as is typeof -> sizeof *-(разыменование) &

(условие)?(выражение1):(выражение2) унарный оператор сравнения

public static тип возвр. данных operator символ оператора ( список параметров)

	Перегрузка унарных операторов

public static тип возвр. данных operator символ оператора ( тип операнд )

Перегрузка постфиксной и префиксной форме операторов отдельно не выделяется
Опреатор - не должен изменять состояние текущего объекта, а возвращать новый объект с измененным знаком.

	Перегрузка бинарных операторов

public static тип возвр. данных operator символ оператора ( тип операнд_1, тип операнд_2)

при применении бинарных операций и встроенного типа данных важен порядок следования операндов
а+10 и 10+а должны иметь два перегруженых метода.

	Операторы отношений

Операторы отношений перегружаются парно
|>,<|  |>=,<=| |==,!=|
Как правило перегруженный оператор отношения возвращает логический тип true или false

	Перегрузка true false
Операторы true false менять в паре

	Перегрузка логического
Перегруженнные логические операторы должны возвращать тип bool
   ---  &   ---   |   ---   !   --- побитовые
   ---  &&  ---   ||  ---   
	
a | b | a&b | a|b | !a
--|---|-----|-----|----
1 | 0 |  0  |  1  | 0
0 | 1 |  0  |  1  | 1 
0 | 0 |  0  |  0  | 1
1 | 1 |  1  |  1  | 0

	Для перегрузки операторов по сокращенной схеме. 
1 перегрузить побитовые операторы
2 должны возвращать объект класса, для которого преегружаются эти операторы
3 каждый параметр должен быть ссылкой на объект класса
4 также необходимо перегрузить операторы тру и фолс
 	
	Перегрузка операторов преоброзования
public static explicit operator тип_рез (исходный.тип v){ return значение;}  // явное
public static implicit operator тип_рез (исходный.тип v){ return значение;}  // неявное

В одном классе нельзя делать одновременную перегрузку двух, только одного




                      ------ Cвойства и индексаторы -------



public тип_возвр_данных ИМЯ{
		set{имя_поля=value;}
		get{return имя_поля}
}

свойства предназначены для организации доступа к закрытым полям класса
свойства заменяют открытые методы, могут иметь аксессоры set и get, в каждом из которых осуществляются проверки присвоения
и возвращения результата переменной, для которой  было создано свойство

Особенности работы со свойствами
1 свойство может содержать один либо два аксессора (отсутствие вааще невозможно!!!!!!) 
2 свойство не может быть перегружено
  свойство не может быть передано в метод параметром ref или out
3 свойство не должно изменять значение переменной в аксессоре get
4 свойство может быть статическим
Один из аксессоров в свойстве может иметь различные варианты спецификаторов доступа
Второй аксессор должен иметь спецификатор доступа соответствующий спецификатору способа доступа

	                     Автоматические свойства 
Для полей класса можно создавать автоматические свойства, тоесть записывать аксессоры get set без тела

public int Size{get; set;}

public int Width {get; private set;}

Должны присутствовать оба значения

  

                  ---------- Индексаторы --------------


Индексатор это разновидность свойства (свойство с параметром), которая применяется для обращения к объектам класса так, словно они являются элементами
коллекции или массива.
Индексатор представляет собой перегрузку оператора квадратные скобки - [ ]
Cbynfrcbc:
спецификатор_доступа тип_эл. this [тип индекс]{
	get{ ... }
	set{ ... }
}

public int this[int i, string y]{
	get{return arr[i]}
	set{if(value>100 || value<0)
	    temp[i]=0;
	else
	    temp[i]=value;
}

Особенности индексаторов:
1 Индексатор имеет имя this и должен приниамать хотя бы один параметр (можно больше)
2 Индексатор может принимать любой тип параметра.
3 В одном классе можно создавать несколько индексаторов, но они должны иметь разные списки принимаемых значений (перегрузка индексаторов)
4 Индексаторы могут иметь могут иметь один или два аксессора (get, set)
5 Индексаторы нельзя передавать в методы в качестве параметров
6 Индексатор должен быть членом экземпляром своего класса, поэтому его нельзя объявлять static

Индексатор может не использовать массив класса, достаточно, чтобы индексатор обеспечивал функционирование, которое для пользователя бы выглядело как работа с массивом.




                ----------- Наследование -----------




Синтаксис:

class Monster {
...
}

class Daemon: Monster{
...
}

Множественное наследвание низзя!!!
Класс может иметь неограниченное кол-во потомков.

private   - только для базового
public    - для всех классов
protected - для наследуемых

Особенности использования конструкторов при наследовании
Конструктор базового класса создает часть объекта соответсвующий базовому классу,
а конструктор проиводдного класса часть. соответсвующую производному классу.
Поэтому при созданиии объекта произв. класса будут выполнены конструкторы произв. и базового классов
Порядок вызова конструктора

1 вызывается конструктор производодного класса
2 вызывается конструктор базового класса
  а) либо по умолчанию,если не т явного
  б) вызов конструктора с параметром, который соответсвует параметрам следующим после ключевого слова base. 
Синтаксис для б:
Конструктор произв констр(параметры()):base(параметры){
...
}


3 Выполнение конструктора базового класса
4 Возврат к телу производного класса и его выполнение

--------- Если в иерархии наследования стоит больше двух классов. то вызов конструкторов осуществляется от производного через базовые
к самому общему базовому классу. а выполнение наоборот 
---------Использование производного слова base
1. это вызов конструктора базового класса (с помощью base вызывается тот конструктор, параметры которого соответствуют переданным аргументам в base
   base всегда отсылает к базовому классу, стоящему непосредственно над вызывающим классом. Если base отсутствует, то автом. вызывается конструктор базового класса по умолчанию
2. для доступа к члену базового класса, который скрыт за членом производного класса
Производный  класс может определить член, имя которого совпадает с именем члена базового класса, В этом случае член базового класса становиться скрытым в производном классе. Данная ситуация не вызовет ошибки. А только предупреждение.  Для предотвращения которого необходимо указать слово new перед членом производного класса. Скрывать можно методы свойства переменные. Для доступа к скрытым элементам из базового класса к производным можно со словом ‘ base. ’
-------Использование ссылок базового класса на производный.
Объект одного класса не может быть присвоен объекту другого класса за исключением того, если они находятся в иерархии наследования
!!!!!!! Ссылки базового класса можно присвоить объект любого производного класса
Class X{
Int a;
}
Class Y:X{
Int b;
}
X x1=new Y();
x1.a=4;
x1.b=4; //Error

Тип ссылочной переменной, а не тип объекта на который она ссылается, определяет, какие члены могут быть доступны.
Чаще всего ссылки типа базовый класс на производный. Используются при создании универсальных методов, которые принимают ссылки базового класса, а передавать в них моно объекты производного класса.
Виртуальным называется метод virtual переопределяется в одном или нескольких производных классах с помощью override
Виртуальные методы имеют смысл, когда они вызываются через ссылку на базовый класс.
!!! Тип объекта, на который указывает ссылка, а не тип ссылки определят какая версия виртуального метода будет выполнена
При переопределении виртуального метода сигнатуры виртуального и метода переопределенного должны совпадать
Виртуальный метод нельзя переопределять как статический. Переопределение виртуальных методов является основой диспетчеризацией методов
Диспетчеризация это механизм вызова преопределенного метода во время выполнения программы, а не во время компиляции. Виртуальный метод в производном классе не обяз, если 
Помимо методов виртуальными могут быть и свойства
Если производный класс не переопределяет класс в случае многоуровневой иерархии, то будет выполнен первый переопределенный метод, который обнаружится при просмотре иерархической лестницы снизу вверх.

--------------------------------------- Абстрактные методы и классы --------------------------------------
    Иногда виртуальный метод в базовом классе не может иметь реализацию, в таком случае вместо виртуальных методов используются абстрактные.
Абстрактный метод объявляется с помощью слова abstract, не имеет тела и в конце ставится точка с запятой. Если виртуальный метод не может  быть переопределен, то абстрактный метод должен быть обязательно переопределен в производном классе с помощью ключевого слова override. Абстрактный метод- есть виртуальный. Поэтому совместное использование не допустимо. Абстрактные методы не могут быть статическими. Если в классе определен хотя бы один абстрактный метод. То такой класс помечается словом abstract. Объекты абстрактного класса создавать нельзя. Если абстрактный метод все же не переопределен в производном классе, то такой класс должен быть помечен как абстрактный. Абстрактными могут быть не только методы, но и свойства.
    Объект абстрактного класса создавать нельзя, но можно создавать ссылку на абстрактный , которые будут указывать на объекты производных классов.

-------------------------------------------------    sealed  ---------------------------------
    Используется перед именем класса для того что бы предотвратить наследование от него. Также позволяет запечатывать переопределенные методы.

------------------  Правила приведения к базовому и производному классу  ---------------------
1.	Когда два класса связаны отношением наследования всегда можно безопасно сохранить объект производного класса в ссылке базового класса (неявное приведение). В .NET конечным базовым классом является класс object, и все созданные классы неявно наследуются от object. Следовательно объект любого класса можно сохранить в ссылке object.
2.	Необходимо явно выполнять приведение «вниз», то есть  от более общего к более частному использую операцию приведения (класс к которому приводим)объект-который приводим
Явное приведение используется 
1.	Для доступа к членам производного класса при обращении через ссылку базового класса.
         Shape S=new Triangle ();
         ((Triangle) S).style;
2.	При передаче в метод ссылки базового класса на производный. Если метод принимает объект производного класса.                                      object T3=new Triangle();                                                                                                                                                                                                                       public static void Show(TwoDShape s){	}

Явное приведение происходит во врем выполнения, а не во время компиляции. Следовательно существует вероятность неправильного приведения типов. Для проверки на правильность
1.	Включить строку try с явным приведением
2.	Использование ключевого слова as. Операция возвращает либо ссылку на новый приведенный объект либо null, если типы не приводятся.
3.	Использование ключевого слова is. Операция возвращает true, если типы совместимы, false, если не совместимы. 			               If (D1 is Triangle){														(Triangle)D1.some;														else …

------------------------  Класс object  -----------------------------------------------
Так как object базовый класс для всех типов языка си шарп, то его можно использовать для обобщенного типа данных. Можно создавать массив типа object и хранить там любые значения.
Ссылка типа object может указывать на значимую переменную, происходит перенос из стека в кучу. Такой процесс называется упаковкой(Boxing).
Приведение к объектному типу осуществляется автоматически.
Int x; //значимый тип (стек)
object obj; // ссылочный
obj =x; //boxing
Обратный процесс восстановления значимого типа из объектного называется распаковка (extracting). Реализуется через явное приведение к явному типу.
Int y=(int)arr[0];
Класс object используется при описании типов методов для придания им общности, а также  для хранения ссылок на объекты различного типа. Таким образом реализуется полиморфизм. 

Класс имеет методы:
Equals – сравнивает объект. Для которого вызван метод с параметром метода на принадлежность к одной и той же области памяти.

GetHashCode      – формирует хеш код объекта и возвращает число однозначно идентифицирующий объект.
GetType                – возвращает тип объекта на который указывает ссылка.
ToString                – для ссылочных типов возвращает имя класса в виде строки, а для значимых значения.
ReferenсeEquals – возвращает true, если два объекта ссылаются на одну область памяти.

-----------   Интерфейсы  ------------

interface Primes{
методы
свойства
индексаторы
события
}

Интерфейс определяет набор функций членов, котррые будут реализованы классом наследником. Сам интерфейс функции члены не реализует.
Один класс может наследоваться от нескольких  интерфейсов. один интерфейс может наследоваться от других классов и интерфейсов
В интерфейсе не могут содержаться поля, конструкторы, деструкторы и операторные методы. В интерфейсе все методы являются неявно открытыми. Не разрешается делать public, protected и так далее.
Для методов указывается только тип, имя члена и список параметров. Ни один из членов не может быть статическим.

public interface ISeries{
int getNext ( );
void reset ( );
void setStart ( int x );
}

Реализация интерфейсов.
При наследовании интерфейса после двоеточия указывается имя базового класса , дальше через запятую имена интерфейсов.
Сигнатуры методов в интерфейсе и классе реализации должны совпадать.
Методы, реализованные в классе интерфейса, должны быть открытыми. В классе, помимо методов реализованных из интерфейса, можно создавать дополнительные члены. Члены интерфейса,  реализованные в классе, могут создаваться виртуальными или абстрактными, но не статическими или константными.
При реализации интерфейса, перед реализуемым членом можно указать  имя интерфейса. В таком случае метод становиться закрытым и доступ к нему будет осуществляться как приведение. 
Если класс реализует унаследованный от другого интерфейса, то в классе должны быть реализованы методы двух интерфейсов.

Интерфейсные ссылки
Точно также как можно создавать ссылки на базовый и указывать их на производные можно создавать интерфейсные ссылки которые будут указывать на объекты классов реализующих интерфейс. !!!Нельзя создавать объекты интерфейсов!!!!!!!!!!!
Интерфейсная ссылка предназначена для обращения к методам реализованным из интерфейса. Для обращения к собственным полям и методам нужно буде делать явное приведение. При вызове метода через интерфейсную ссылку будет выполнен тот метод, на объект которого указывает интерфейсная ссылка.

Предположим что создан массив типа shape который содержит объекты производных классов, причем некоторые объекты поддерживают объект IPonty. А некоторые не поддерживают. Для определения во время работы программы поддерживает ли объект интерфейс, используется несколько способов:
-- Явное приведение объекта к интерфейсу и заключение этой операции в блок трай.
-- Использование ключевого слова as.
-- Использование ключевого слова is.

Использование интерфейсов в качестве параметров
Методы могут принимать интерфейсные ссылки, что позволяет передавать в такие методы объекты различных типов несвязанные между собой кроме как интерфейсом.
Интерфейсная ссылки можно не только передавать но и возвращать из методов. 

При наследовании классов от нескольких интерфейсов, существует вероятность совпадения имен методов. В таком случае в классе в названии реализуемого метода необходимо предварять именем интерфейса с точкой. Указывать модификатор доступа для такого реализуемого метода не  требуется, так как автоматически он приватный. Следовательно доступ к такому члену будет осуществляться через явное приведение объекта класса к соответствующей интерфейсной ссылке. 

---------------- Структуры ------
Это пользовательский тип данных, который состоит из набора, полей, методов, свойств, событий и является значимым(не ссылочным) типом данных.
Синтаксис структуры:
public struct TmpName{
…
}   

Особенности:
- При присвоении переменной типа структура к другой переменной будет происходить полное копирование элементов структуры. Также при передаче структуры в метод, измененное значение структуры не будет изменено после выхода из метода.
- Переменную типа структуры можно создавать с помощью ключевого слова new, которое в отличие от классов память не выделяет, а запускает конструктор для инициализации полей структуры. Ключевое слово new использовать не обязательно. Структура может содержать перегруженный конструктор, за исключением переопределения конструктора по умолчанию. Конструктор по умолчанию инициализирует поля нулями.
- Инициализация полей внутри запрещена. 
- Структуры не поддерживают наследований от классов, а только от интерфейсов, следовательно, спецификатор protected для членов структуры не используется. Статические переменные допускаются.
- структуры неявно унаследованы от System.ValueType ->System.Object, следовательно, структурам доступны методы класса ValueType и Object. 

---  Перечисления  ---
Перечисления 
Значения константам автоматически 

-----------------  Делегаты ----------------
System.Delegate
Delegate тип_возврата имя (список параметров);
Делегат – это объект, который может ссылаться на метод.

ChangeString str = new ChangeString ( );
string tmpStr = "this is a man`s world!";
D d = new D (str.change1);
Console.WriteLine (d(tmpStr));
d = ChangeString.change2;
Console.WriteLine (d (tmpStr));

Многоадресная передача – это способность создавать список вызовов методов, автоматически, вызываемые делегатом.
Для этого необходимо:
- создать экземпляр делегата
- для добавления    “+=”
- для удаления         “-=” 

Передача делегата в метод

1 delegate int D (string);  //создаем делегата 
2 public int Fun(string s){ return int.Parse(s); }   //
3 метод прин. Делегат
   Public static void Method ( ref int x, D d){ string s = “25”; x=d1(s); }
4 Main(){
Int x=0;
Method ( x, new D(Fun));

Event событийный_делегат объект;
1 Событие – это автоматическое уведомление о выполнении некоторого действия.
2 

Чтобы управлять списком обработчиков событий, можно использовать вторую форму event инструкции, которая содержит два аксессора add и remove,
Которые вызываются в случае добавления и удаления обработчика.


Collections
1 Необобщенные – это структуры данных общего назначения, оперирующие ссылками на объекты                                           Systems.Collections
2 Обобщенные – являются типизированными, то есть в них можно хранить только те элементы ,
   которые совместимы по типу с ее аргументом                                                                                                                                            Systems.Collections.Generic
3 Специализированная - оперирует данными конкретного типа
4 Поразрядная – поддерживает операции над отдельными двоичными разрядами.                                                                         BitArray
5 Паралельные – поддерживают многопоточный доступ к такой коллекции                                                                                         Systems.Collections.Concurrent
